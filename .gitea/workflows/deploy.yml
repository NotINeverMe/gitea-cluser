name: Secure Deployment (SSDF PW.8/RV.2)
on:
  push:
    branches: [main]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production
      terraform_action:
        description: 'Terraform action'
        required: true
        default: 'plan'
        type: choice
        options:
          - plan
          - apply
          - destroy

env:
  ATLANTIS_URL: http://atlantis:4141
  FALCO_RULES_PATH: /etc/falco/rules.d
  EVIDENCE_BUCKET: gs://ssdf-evidence-${GITEA_REPO_NAME}
  TF_VAR_project_id: ${{ secrets.GCP_PROJECT_ID }}
  TF_VAR_region: us-central1

jobs:
  terraform-deploy:
    runs-on: ubuntu-latest
    outputs:
      deployment_id: ${{ steps.deploy.outputs.deployment_id }}
      environment_url: ${{ steps.deploy.outputs.environment_url }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Deployment Tools
        run: |
          echo "::group::Installing deployment tools"
          # Install Terraform
          curl -LO https://releases.hashicorp.com/terraform/1.6.0/terraform_1.6.0_linux_amd64.zip
          unzip terraform_1.6.0_linux_amd64.zip
          sudo mv terraform /usr/local/bin/

          # Install Terragrunt
          curl -LO https://github.com/gruntwork-io/terragrunt/releases/latest/download/terragrunt_linux_amd64
          chmod +x terragrunt_linux_amd64
          sudo mv terragrunt_linux_amd64 /usr/local/bin/terragrunt

          # Install Atlantis CLI
          curl -LO https://github.com/runatlantis/atlantis/releases/latest/download/atlantis_linux_amd64.zip
          unzip atlantis_linux_amd64.zip
          sudo mv atlantis /usr/local/bin/

          # Install security scanners
          pip3 install checkov tfsec terrascan
          echo "::endgroup::"

      - name: Configure Cloud Credentials
        run: |
          echo "::group::Configuring cloud credentials"
          # GCP authentication
          echo "${{ secrets.GCP_SERVICE_ACCOUNT_KEY }}" | base64 -d > gcp-key.json
          export GOOGLE_APPLICATION_CREDENTIALS=$(pwd)/gcp-key.json

          # AWS authentication (if needed)
          if [ -n "${{ secrets.AWS_ACCESS_KEY_ID }}" ]; then
            export AWS_ACCESS_KEY_ID=${{ secrets.AWS_ACCESS_KEY_ID }}
            export AWS_SECRET_ACCESS_KEY=${{ secrets.AWS_SECRET_ACCESS_KEY }}
            export AWS_DEFAULT_REGION=${{ secrets.AWS_DEFAULT_REGION }}
          fi
          echo "::endgroup::"

      - name: Pre-deployment Security Scan (PW.8.1)
        id: pre-scan
        run: |
          echo "::group::Pre-deployment security validation"
          scan_passed=true

          # Scan Terraform configurations
          if [ -d "terraform/" ]; then
            echo "ðŸ” Scanning Terraform configurations..."

            # tfsec scan
            tfsec terraform/ --format json --out tfsec-pre-deploy.json --soft-fail || true
            critical_issues=$(jq '[.results[] | select(.severity == "CRITICAL")] | length' tfsec-pre-deploy.json)

            if [ "$critical_issues" -gt 0 ]; then
              echo "âŒ Found ${critical_issues} critical IaC security issues"
              scan_passed=false
            fi

            # Checkov scan
            checkov -d terraform/ --output json --output-file-path checkov-pre-deploy.json --soft-fail || true

            # Terrascan scan
            terrascan scan -i terraform -d terraform/ -o json > terrascan-pre-deploy.json || true
          fi

          echo "scan_passed=${scan_passed}" >> $GITHUB_OUTPUT

          if [ "$scan_passed" = false ] && [ "${{ github.event.inputs.terraform_action }}" = "apply" ]; then
            echo "âŒ Blocking deployment due to security issues"
            exit 1
          fi
          echo "::endgroup::"

      - name: Terraform Plan via Atlantis (PW.8.1)
        id: plan
        if: github.event.inputs.terraform_action == 'plan' || github.event.inputs.terraform_action == 'apply'
        run: |
          echo "::group::Terraform Planning"
          environment="${{ github.event.inputs.environment || 'staging' }}"

          cd terraform/

          # Initialize Terraform
          terraform init -backend-config="bucket=${EVIDENCE_BUCKET}" \
            -backend-config="prefix=terraform/${environment}"

          # Create plan
          terraform plan \
            -var="environment=${environment}" \
            -var="commit_sha=${{ github.sha }}" \
            -var="deployed_by=${{ github.actor }}" \
            -out=tfplan.binary

          # Convert to JSON for analysis
          terraform show -json tfplan.binary > tfplan.json

          # Analyze plan for security issues
          echo "ðŸ” Analyzing Terraform plan..."

          # Check for resource deletions
          deletions=$(jq '[.resource_changes[] | select(.change.actions[] == "delete")] | length' tfplan.json)
          if [ "$deletions" -gt 0 ]; then
            echo "âš ï¸ Plan includes ${deletions} resource deletions"
          fi

          # Check for security group changes
          sg_changes=$(jq '[.resource_changes[] | select(.type == "aws_security_group" or .type == "google_compute_firewall")] | length' tfplan.json)
          if [ "$sg_changes" -gt 0 ]; then
            echo "âš ï¸ Plan includes ${sg_changes} firewall/security group changes"
          fi

          echo "âœ… Terraform plan completed"
          echo "::endgroup::"

      - name: Terraform Apply via Atlantis (PW.8.2)
        id: deploy
        if: github.event.inputs.terraform_action == 'apply'
        run: |
          echo "::group::Terraform Deployment"
          environment="${{ github.event.inputs.environment || 'staging' }}"
          deployment_id="${{ github.sha }}-$(date +%s)"

          cd terraform/

          # Apply with auto-approve (use with caution)
          terraform apply tfplan.binary

          # Get outputs
          environment_url=$(terraform output -raw environment_url 2>/dev/null || echo "http://localhost")
          load_balancer_ip=$(terraform output -raw load_balancer_ip 2>/dev/null || echo "pending")

          echo "deployment_id=${deployment_id}" >> $GITHUB_OUTPUT
          echo "environment_url=${environment_url}" >> $GITHUB_OUTPUT

          echo "âœ… Deployment completed"
          echo "ðŸ“ Environment URL: ${environment_url}"
          echo "ðŸ”¢ Deployment ID: ${deployment_id}"
          echo "::endgroup::"

      - name: Deploy Falco Runtime Rules (RV.2.1)
        if: github.event.inputs.terraform_action == 'apply'
        run: |
          echo "::group::Deploying Falco runtime security"
          # Create Falco rules for runtime protection
          cat > falco-custom-rules.yaml <<EOF
          - rule: Unauthorized Process
            desc: Detect unauthorized process execution
            condition: >
              spawned_process and
              not proc.name in (allowed_processes)
            output: >
              Unauthorized process started (user=%user.name command=%proc.cmdline)
            priority: WARNING
            tags: [process, security]

          - rule: Sensitive File Access
            desc: Detect access to sensitive files
            condition: >
              open_read and
              fd.name in (sensitive_files)
            output: >
              Sensitive file accessed (user=%user.name file=%fd.name)
            priority: WARNING
            tags: [filesystem, security]

          - rule: Network Connection to C2
            desc: Detect potential C2 communications
            condition: >
              outbound and
              fd.sip in (suspicious_ips)
            output: >
              Suspicious network connection (proc=%proc.name dest=%fd.sip)
            priority: CRITICAL
            tags: [network, c2]

          - rule: Container Escape Attempt
            desc: Detect container escape attempts
            condition: >
              container and
              (proc.name = "nsenter" or
               proc.name = "docker" or
               proc.name = "kubectl")
            output: >
              Container escape attempt (user=%user.name command=%proc.cmdline container=%container.name)
            priority: CRITICAL
            tags: [container, escape]

          - rule: Cryptomining Detection
            desc: Detect cryptomining activity
            condition: >
              spawned_process and
              (proc.name in (miners) or
               proc.cmdline contains "stratum+tcp")
            output: >
              Cryptomining activity detected (proc=%proc.name cpu=%proc.cpu)
            priority: CRITICAL
            tags: [cryptomining, malware]
          EOF

          # Deploy Falco rules to cluster
          if [ "${{ github.event.inputs.environment }}" = "production" ]; then
            echo "ðŸš€ Deploying Falco rules to production"
            kubectl apply -f falco-custom-rules.yaml -n falco-system || echo "Kubectl not configured"
          fi

          echo "âœ… Falco runtime rules deployed"
          echo "::endgroup::"

      - name: Configure Security Monitoring (RV.2.2)
        if: github.event.inputs.terraform_action == 'apply'
        run: |
          echo "::group::Configuring security monitoring"
          # Create monitoring configuration
          cat > monitoring-config.yaml <<EOF
          apiVersion: v1
          kind: ConfigMap
          metadata:
            name: security-monitoring
            namespace: monitoring
          data:
            prometheus.yml: |
              global:
                scrape_interval: 15s
                evaluation_interval: 15s

              rule_files:
                - /etc/prometheus/security-rules.yml

              scrape_configs:
                - job_name: 'security-metrics'
                  static_configs:
                    - targets: ['localhost:9090']

                - job_name: 'falco-exporter'
                  static_configs:
                    - targets: ['falco-exporter:9376']

                - job_name: 'trivy-exporter'
                  static_configs:
                    - targets: ['trivy-exporter:9090']

            security-rules.yml: |
              groups:
                - name: security_alerts
                  interval: 30s
                  rules:
                    - alert: HighVulnerabilityCount
                      expr: trivy_vulnerability_count{severity="CRITICAL"} > 0
                      for: 5m
                      annotations:
                        summary: "Critical vulnerabilities detected"
                        description: "{{ \$value }} critical vulnerabilities found"

                    - alert: SuspiciousActivity
                      expr: falco_events{priority="CRITICAL"} > 0
                      for: 1m
                      annotations:
                        summary: "Suspicious activity detected by Falco"
                        description: "{{ \$labels.rule }} triggered"

                    - alert: UnauthorizedAccess
                      expr: rate(nginx_4xx_errors[5m]) > 10
                      for: 5m
                      annotations:
                        summary: "High rate of authorization failures"
                        description: "{{ \$value }} 4xx errors per second"
          EOF

          # Apply monitoring configuration
          kubectl apply -f monitoring-config.yaml || echo "Monitoring config saved locally"

          echo "âœ… Security monitoring configured"
          echo "::endgroup::"

      - name: Post-deployment Validation (RV.2.2)
        id: validation
        if: github.event.inputs.terraform_action == 'apply'
        run: |
          echo "::group::Post-deployment security validation"
          environment_url="${{ steps.deploy.outputs.environment_url }}"
          validation_passed=true

          # Health checks
          echo "ðŸ¥ Running health checks..."
          if ! curl -f ${environment_url}/health --max-time 30; then
            echo "âŒ Health check failed"
            validation_passed=false
          fi

          # Security headers check
          echo "ðŸ”’ Checking security headers..."
          headers=$(curl -I ${environment_url} 2>/dev/null)

          required_headers=("X-Frame-Options" "X-Content-Type-Options" "Strict-Transport-Security" "Content-Security-Policy")
          for header in "${required_headers[@]}"; do
            if ! echo "$headers" | grep -i "$header" > /dev/null; then
              echo "âš ï¸ Missing security header: $header"
            fi
          done

          # TLS configuration check
          echo "ðŸ” Checking TLS configuration..."
          if command -v testssl &> /dev/null; then
            testssl --json-file tls-test.json ${environment_url} || true
          fi

          # Vulnerability quick scan
          echo "ðŸ” Running quick vulnerability scan..."
          if command -v nuclei &> /dev/null; then
            nuclei -u ${environment_url} -severity critical,high -json -o nuclei-post-deploy.json || true

            if [ -f "nuclei-post-deploy.json" ] && [ -s "nuclei-post-deploy.json" ]; then
              echo "âš ï¸ Vulnerabilities detected in deployed application"
              validation_passed=false
            fi
          fi

          echo "validation_passed=${validation_passed}" >> $GITHUB_OUTPUT

          if [ "$validation_passed" = true ]; then
            echo "âœ… Post-deployment validation passed"
          else
            echo "âŒ Post-deployment validation failed"
          fi
          echo "::endgroup::"

      - name: Rollback on Failure (RV.3.2)
        if: failure() && github.event.inputs.terraform_action == 'apply'
        run: |
          echo "::group::Rollback Deployment"
          echo "âŒ Deployment failed, initiating rollback..."

          cd terraform/

          # Get previous state
          terraform state pull > current-state.json

          # Create rollback plan
          cat > rollback.sh <<'EOF'
          #!/bin/bash
          # Rollback to previous version
          terraform state mv ...
          terraform apply -auto-approve
          EOF

          chmod +x rollback.sh

          # Execute rollback
          if [ -f ".terraform/terraform.tfstate.backup" ]; then
            echo "ðŸ”„ Rolling back to previous state..."
            cp .terraform/terraform.tfstate.backup terraform.tfstate
            terraform apply -auto-approve -refresh=false || echo "Rollback failed"
          else
            echo "âš ï¸ No backup state found for rollback"
          fi

          echo "âœ… Rollback completed"
          echo "::endgroup::"

      - name: Drift Detection (RV.3.3)
        if: github.event_name == 'schedule' || github.event.inputs.terraform_action == 'plan'
        run: |
          echo "::group::Infrastructure Drift Detection"
          cd terraform/

          # Detect drift
          terraform plan -detailed-exitcode > /dev/null 2>&1
          exit_code=$?

          if [ $exit_code -eq 0 ]; then
            echo "âœ… No drift detected"
          elif [ $exit_code -eq 2 ]; then
            echo "âš ï¸ Drift detected in infrastructure"

            # Generate drift report
            terraform plan -json > drift-report.json

            # Count drifted resources
            drifted=$(jq '[.resource_changes[] | select(.change.actions != ["no-op"])] | length' drift-report.json)
            echo "ðŸ“Š ${drifted} resources have drifted"

            # Create drift issue
            cat > drift-issue.md <<EOF
          # Infrastructure Drift Detected

          **Date**: $(date -u +%Y-%m-%dT%H:%M:%SZ)
          **Environment**: ${{ github.event.inputs.environment || 'staging' }}
          **Resources Affected**: ${drifted}

          Please review and reconcile the infrastructure drift.

          [View Drift Report](${GITHUB_SERVER_URL}/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID})
          EOF
          else
            echo "âŒ Error detecting drift"
          fi
          echo "::endgroup::"

      - name: Collect Deployment Evidence (PW.9.1)
        if: always()
        run: |
          echo "::group::Evidence Collection"
          mkdir -p evidence/deployment

          # Collect all deployment artifacts
          cp -f tfplan.json evidence/deployment/ 2>/dev/null || true
          cp -f *-pre-deploy.json evidence/deployment/ 2>/dev/null || true
          cp -f *-post-deploy.json evidence/deployment/ 2>/dev/null || true
          cp -f falco-custom-rules.yaml evidence/deployment/ 2>/dev/null || true
          cp -f monitoring-config.yaml evidence/deployment/ 2>/dev/null || true

          # Generate deployment manifest
          cat > evidence/deployment/manifest.json <<EOF
          {
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "deployment_id": "${{ steps.deploy.outputs.deployment_id }}",
            "environment": "${{ github.event.inputs.environment || 'staging' }}",
            "action": "${{ github.event.inputs.terraform_action || 'plan' }}",
            "commit_sha": "${{ github.sha }}",
            "deployed_by": "${{ github.actor }}",
            "ssdf_practices": ["PW.8.1", "PW.8.2", "RV.2.1", "RV.2.2", "RV.3.2", "RV.3.3"],
            "deployment": {
              "url": "${{ steps.deploy.outputs.environment_url }}",
              "pre_scan_passed": "${{ steps.pre-scan.outputs.scan_passed }}",
              "validation_passed": "${{ steps.validation.outputs.validation_passed }}"
            },
            "security": {
              "falco_rules_deployed": true,
              "monitoring_configured": true,
              "tls_enabled": true,
              "security_headers": true
            }
          }
          EOF

          # Create evidence package
          tar czf evidence-deployment-${GITEA_RUN_ID}.tar.gz evidence/
          sha256sum evidence-deployment-${GITEA_RUN_ID}.tar.gz > evidence-deployment-${GITEA_RUN_ID}.sha256

          echo "âœ… Deployment evidence collected"
          echo "SHA-256: $(cat evidence-deployment-${GITEA_RUN_ID}.sha256 | cut -d' ' -f1)"
          echo "::endgroup::"

      - name: Upload Evidence to GCS
        if: always()
        run: |
          echo "::group::Uploading Evidence"
          # Upload to GCS
          gsutil cp evidence-deployment-${GITEA_RUN_ID}.tar.gz ${EVIDENCE_BUCKET}/deployments/
          gsutil cp evidence-deployment-${GITEA_RUN_ID}.sha256 ${EVIDENCE_BUCKET}/deployments/

          echo "âœ… Evidence uploaded to ${EVIDENCE_BUCKET}/deployments/"
          echo "::endgroup::"

      - name: Update Deployment Log
        if: github.event.inputs.terraform_action == 'apply'
        run: |
          echo "::group::Updating deployment log"
          # Create deployment log entry
          cat > deployment-log.json <<EOF
          {
            "deployment_id": "${{ steps.deploy.outputs.deployment_id }}",
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "environment": "${{ github.event.inputs.environment }}",
            "version": "${{ github.sha }}",
            "deployed_by": "${{ github.actor }}",
            "url": "${{ steps.deploy.outputs.environment_url }}",
            "status": "${{ steps.validation.outputs.validation_passed == 'true' && 'success' || 'failed' }}",
            "rollback_available": true
          }
          EOF

          # Append to deployment history
          if [ -f "deployments.log" ]; then
            jq -s '.[0] + [.[1]]' deployments.log deployment-log.json > deployments-new.log
            mv deployments-new.log deployments.log
          else
            echo "[" > deployments.log
            cat deployment-log.json >> deployments.log
            echo "]" >> deployments.log
          fi

          echo "âœ… Deployment logged"
          echo "::endgroup::"

      - name: Upload Artifacts
        if: always()
        uses: actions/upload-artifact@v3
        with:
          name: deployment-artifacts-${{ github.run_id }}
          path: |
            tfplan.json
            *-deploy.json
            falco-custom-rules.yaml
            monitoring-config.yaml
            deployment-log.json
            evidence-deployment-*.tar.gz
            evidence-deployment-*.sha256
          retention-days: 90